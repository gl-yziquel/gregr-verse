#lang racket
;; This is a leaf-oriented, immutable B-Tree implementation in terms of
;; efficient bulk operations, inspired by:
;;   Blelloch, Ferizovic, Sun; Parallel Ordered Sets Using Join
;;   (https://arxiv.org/abs/1602.02120).
;; Bulk operations are implemented in terms of split and link
;; (so-called to avoid confusion with the lattice operation "join").
;; NOTE: for bookkeeping convenience, many spurious allocations and copies are
;; performed.  Though these should not affect asymptotic complexity,
;; eliminating them may significantly improve efficiency.  Additionally, nodes
;; may be given a packed representation as a single vector in order to reduce
;; the number of indirect memory accesses.
;; TODO: support augmented maps.  Example: annotating each node with the total
;; number of values under it, supporting splitting on position
;; (e.g., k smallest elements vs. everything else).
(provide
  btree-parameters
  btree-union/merge
  btree-union
  alist->btree
  )

(define (vector-copy-to vsrc start end vtgt itgt)
  (let loop ((i start) (itgt itgt))
    (unless (= i end)
      (vector-set! vtgt itgt (vector-ref vsrc i))
      (loop (+ i 1) (+ itgt 1)))))

;; TODO: value->aug, aug-combine, aug-empty.
(define (btree-parameters degree compare)
  (unless (and (integer? degree) (<= 4 degree))
    (error "invalid btree-parameters degree:" degree))
  (cons degree compare))
(define (btree-parameters-degree p)  (car p))
(define (btree-parameters-compare p) (cdr p))

(define bempty      '())
(define (bempty? b) (null? b))
;; TODO: support index/augmentation values (such as a count or sum).
(define (bnode keys children) (cons keys children))
(define (bnode-keys b)        (car b))
(define (bnode-children b)    (cdr b))

(define (hbnode h b)      (cons h b))
(define (hbnode-height b) (car b))
(define (hbnode-node b)   (cdr b))
;; TODO: manage augmentation values during construction.
(define (bbranch keys children)    (bnode keys children))
(define (bleaf keys values)        (bnode keys values))
(define (hbbranch h keys children) (hbnode h (bbranch keys children)))
(define (hbleaf keys values)       (hbnode 0 (bleaf keys values)))

(define (keys-ref keys i) (and (< -1 i (vector-length keys))
                               (vector-ref keys i)))
(define (hbbranch-take hb n)
  (match-define (cons h b) hb)
  (cond ((= n 0) bempty)
        ((= n 1) (cons (- h 1) (vector-ref (bnode-children b) 0)))
        (else    (cons h (bnode (vector-take (bnode-keys b) (- n 1))
                                (vector-take (bnode-children b) n))))))
(define (hbbranch-drop hb n)
  (match-define (cons h b) hb)
  (define vc (bnode-children b))
  (define vclen (vector-length vc))
  (define ilast (- vclen 1))
  (cond ((= n vclen) bempty)
        ((= n ilast) (cons (- h 1) (vector-ref (bnode-children b) ilast)))
        (else        (cons h (bnode (vector-drop (bnode-keys b) n)
                                    (vector-drop (bnode-children b) n))))))
(define (hbnode-take hb n)
  (define b (hbnode-node hb))
  (cond ((= n 0)                  bempty)
        ((= 0 (hbnode-height hb)) (hbleaf (vector-take (bnode-keys b) n)
                                          (vector-take (bnode-children b) n)))
        (else                    (hbbranch-take hb n))))
(define (hbnode-drop hb n)
  (define b (hbnode-node hb))
  (cond ((= n (vector-length (bnode-children b))) bempty)
        ((= 0 (hbnode-height hb)) (hbleaf (vector-drop (bnode-keys b) n)
                                          (vector-drop (bnode-children b) n)))
        (else                     (hbbranch-drop hb n))))

(define (btree-private params)
  (match-define (cons degree compare) params)
  (define (bisect/range key keys start end)
    (cond ((< start end) (define i (+ start (quotient (- end start) 2)))
                         (case (compare (vector-ref keys i) key)
                           ((-1) (bisect/range key keys (+ 1 i) end))
                           (( 1) (bisect/range key keys start   i))
                           (( 0) (cons #t i))))
          (else          (cons #f start))))
  (define (bisect key keys) (bisect/range key keys 0 (vector-length keys)))

  (define (blink key hbl hbr)
    (cond ((bempty? hbl) hbr)
          ((bempty? hbr) hbl)
          (else
            (define hl  (hbnode-height hbl))
            (define hr  (hbnode-height hbr))
            (define bl  (hbnode-node hbl))
            (define br  (hbnode-node hbr))
            (define ksl (bnode-keys bl))
            (define ksr (bnode-keys br))
            (define csl (bnode-children bl))
            (define csr (bnode-children br))
            (define nl  (vector-length csl))
            (define nr  (vector-length csr))
            (cond ((and (= hl (+ hr 1)) (< nl degree) (<= degree (+ nr nr)))
                   (hbbranch hl
                             (vector-append ksl (vector key))
                             (vector-append csl (vector br))))
                  ((and (= (+ hl 1) hr) (< nr degree) (<= degree (+ nl nl)))
                   (hbbranch hr
                             (vector-append (vector key) ksr)
                             (vector-append (vector bl) csr)))
                  ((< hl hr) (blink (keys-ref ksr 0)
                                    (blink key hbl (hbbranch-take hbr 1))
                                    (hbbranch-drop hbr 1)))
                  ((> hl hr) (define llen (- nl 1))
                             (blink (keys-ref ksl (- (vector-length ksl) 1))
                                    (hbbranch-take hbl llen)
                                    (blink key (hbbranch-drop hbl llen) hbr)))
                  ((< nr (- degree nl))
                   (define keys (if (= 0 hl)
                                  (vector-append ksl ksr)
                                  (vector-append ksl (vector key) ksr)))
                   (hbbranch hl keys (vector-append csl csr)))
                  ((<= degree (* 2 (min nl nr)))
                   (hbbranch (+ hl 1) (vector key) (vector bl br)))
                  ((< nl nr)
                   (define d (quotient (- nr nl) 2))
                   (define keys (if (= 0 hl)
                                  (vector-append ksl (vector-take ksr d))
                                  (vector-append ksl (vector key)
                                                 (vector-take ksr (- d 1)))))
                   (define bln
                     (bbranch keys (vector-append csl (vector-take csr d))))
                   (define brn
                     (bbranch (vector-drop ksr d) (vector-drop csr d)))
                   (hbbranch (+ hl 1)
                             (vector (keys-ref ksr (if (= 0 hl) d (- d 1))))
                             (vector bln brn)))
                  ((> nl nr)
                   (define d (quotient (- nl nr) 2))
                   (define keys
                     (if (= 0 hl)
                       (vector-append (vector-take-right ksl d) ksr)
                       (vector-append (vector-take-right ksl (- d 1))
                                      (vector key) ksr)))
                   (define bln (bbranch (vector-drop-right ksl d)
                                        (vector-drop-right csl d)))
                   (define brn
                     (bbranch keys (vector-append
                                     (vector-take-right csl d) csr)))
                   (hbbranch (+ hl 1)
                             (vector (keys-ref ksl (- (vector-length ksl) d)))
                             (vector bln brn)))
                  (else (error "impossible"))))))

  (define (bsplit key hb)
    (define h    (hbnode-height hb))
    (define b    (hbnode-node hb))
    (define keys (bnode-keys b))
    (define cs   (bnode-children b))
    (define clen (vector-length cs))
    (cond ((= 0 h)
           (define i (cdr (bisect key keys)))
           (cond ((= i 0)    (cons bempty             hb))
                 ((= i clen) (cons hb                 bempty))
                 (else       (cons (hbnode-take hb i) (hbnode-drop hb i)))))
          (else (match-define (cons found? i) (bisect key keys))
                (cond (found? (cons (hbbranch-take hb (+ i 1))
                                    (hbbranch-drop hb (+ i 1))))
                      (else (define pc
                              (bsplit key (hbnode (- h 1) (vector-ref cs i))))
                            (cons (blink (keys-ref keys (- i 1))
                                         (hbbranch-take hb i)
                                         (car pc))
                                  (blink (keys-ref keys i)
                                         (cdr pc)
                                         (hbbranch-drop hb (+ i 1)))))))))

  (define (bcombine combine hba hbb)
    (define (combine/flip b a) (combine a b))
    (let loop ((cmb combine) (cmb/f combine/flip) (hba hba) (hbb hbb))
      (cond ((or (bempty? hba) (bempty? hbb)
                 (= 0 (hbnode-height hba) (hbnode-height hbb)))
             (cmb hba hbb))
            ((and (< (hbnode-height hba) (hbnode-height hbb)))
             (loop cmb/f cmb hbb hba))
            (else (define ba (hbnode-node hba))
                  (define ksa (bnode-keys ba))
                  (define mid (quotient (vector-length ksa) 2))
                  (define kmid (vector-ref ksa mid))
                  (match-define (cons hbbl hbbr) (bsplit kmid hbb))
                  (define cmid (if (= 0 (hbnode-height hba)) mid (+ mid 1)))
                  (define hbal (hbnode-take hba cmid))
                  (define hbar (hbnode-drop hba cmid))
                  (define newl (loop cmb cmb/f hbal hbbl))
                  (define newr (loop cmb cmb/f hbar hbbr))
                  (if (and (eq? hbal newl) (eq? hbar newr)) hba
                    (blink kmid newl newr))))))

  (vector bsplit blink bcombine))

(define (btree params height b) (vector 'btree params height b))
(define (btree? b)              (and (vector? b) (= 4 (vector-length b))
                                     (eq? 'btree (vector-ref b 0))))
(define (btree-params b)        (vector-ref b 1))
(define (btree-height b)        (vector-ref b 2))
(define (btree-node b)          (vector-ref b 3))
(define (btree-compatible?! a b)
  (unless (equal? (btree-params a) (btree-params b))
    (error "incompatible btrees:" a b)))

(define (btree-combine combine a b)
  (btree-compatible?! a b)
  (define params (btree-params a))
  (match-define (vector _ _ bcombine) (btree-private params))
  (define ba (btree-node a))
  (define bb (btree-node b))
  (define hba (hbnode (btree-height a) ba))
  (define hbb (hbnode (btree-height b) bb))
  (define hbc (bcombine combine hba hbb))
  (define bc (and (not (bempty? hbc)) (hbnode-node hbc)))
  (cond ((or (eq? ba hbc) (eq? bb hbc) (eq? ba bc) (eq? bb bc)) a)
        ((bempty? hbc) (btree params 0                   bempty))
        (else          (btree params (hbnode-height hbc) (hbnode-node hbc)))))

(define (btree-union/merge merge a b)
  (define degree (btree-parameters-degree (btree-params a)))
  (define compare (btree-parameters-compare (btree-params a)))
  (match-define (vector _ blink _) (btree-private (btree-params a)))
  (define (combine hba hbb)
    (cond ((bempty? hba) hbb)
          ((bempty? hbb) hba)
          (else (define ba  (hbnode-node hba))
                (define bb  (hbnode-node hbb))
                (define ksa (bnode-keys ba))
                (define ksb (bnode-keys bb))
                (define vsa (bnode-children ba))
                (define vsb (bnode-children bb))
                (define la  (vector-length vsa))
                (define lb  (vector-length vsb))
                (define l   (+ la lb))
                (define l0  (min degree l))
                (let loop ((more #f)
                           (ksc (make-vector l0 #t))
                           (vsc (make-vector l0 #t))
                           (ia 0) (ib 0) (i 0) (len l0))
                  (define (finish ksx vsx ix lx x=a?)
                    (define extra (- (- len i) (- lx ix)))
                    (cond ((= extra 0)
                           (vector-copy-to ksx ix lx ksc i)
                           (vector-copy-to vsx ix lx vsc i)
                           (define leaf (hbleaf ksc vsc))
                           (define key (vector-ref ksc 0))
                           (if more (blink key more leaf) leaf))
                          ((> 0 extra)
                           (define jx (+ lx extra))
                           (vector-copy-to ksx ix jx ksc i)
                           (vector-copy-to vsx ix jx vsc i)
                           (loop (hbleaf ksc vsc)
                                 (make-vector (- extra) #t)
                                 (make-vector (- extra) #t)
                                 (if x=a? jx ia) (if x=a? ib jx) 0 (- extra)))
                          (else (define ksd (make-vector (- len extra) #t))
                                (define vsd (make-vector (- len extra) #t))
                                (vector-copy-to ksc 0 i ksd 0)
                                (vector-copy-to vsc 0 i vsd 0)
                                (loop more ksd vsd ia ib i (- len extra)))))
                  (cond ((= ia la) (finish ksb vsb ib lb #f))
                        ((= ib lb) (finish ksa vsa ia la #t))
                        ((= i len) (define extra (+ (- la ia) (- lb ib)))
                                   (loop (hbleaf ksc vsc)
                                         (make-vector extra #t)
                                         (make-vector extra #t)
                                         ia ib 0 extra))
                        (else
                          (define ka (vector-ref ksa ia))
                          (define kb (vector-ref ksb ib))
                          (case (compare ka kb)
                            ((-1) (vector-set! ksc i ka)
                                  (vector-set! vsc i (vector-ref vsa ia))
                                  (loop more ksc vsc (+ ia 1) ib (+ i 1) len))
                            (( 1) (vector-set! ksc i kb)
                                  (vector-set! vsc i (vector-ref vsb ib))
                                  (loop more ksc vsc ia (+ ib 1) (+ i 1) len))
                            (( 0) (vector-set! ksc i ka)
                                  (vector-set!
                                    vsc i (merge (vector-ref vsa ia)
                                                 (vector-ref vsb ib)))
                                  (loop more ksc vsc
                                        (+ ia 1) (+ ib 1) (+ i 1) len)))))))))
  (btree-combine combine a b))

(define (btree-union a b) (btree-union/merge (lambda (a b) a) a b))

;; TODO:
;(define (btree-intersection merge a b)
  ;)
;(define (btree-difference merge a b)
  ;)
;(define (btree-split b key)
  ;)
;(define (btree->alist b)
  ;)

;; TODO: augmented map queries.  Maybe rename aug to index.
;(define (btree-split-left/aug b threshold))
;(define (btree-split-right/aug b threshold))
;(define (btree-filter/aug b threshold))

(define (alist->btree/merge merge params kvs)
  (if (null? kvs) (btree params 0 bempty)
    (let loop ((bs (map (lambda (kv)
                          (define b (bleaf (vector (car kv))
                                           (vector (cdr kv))))
                          (btree params 0 b))
                        kvs))
               (merged '()))
      (cond ((and (pair? bs) (null? (cdr bs)) (null? merged)) (car bs))
            ((and (pair? bs) (null? (cdr bs)))
             (loop '() (cons (car bs) merged)))
            ((null? bs) (loop (reverse merged) '()))
            (else (loop (cddr bs)
                        (cons (btree-union/merge merge (car bs) (cadr bs))
                              merged)))))))

(define (alist->btree params kvs)
  (alist->btree/merge (lambda (a b) a) params kvs))

;; TODO: derived operations.
;(define (btree-ref/index b i))
;(define (btree-ref))                        ;; intersection
;(define (btree-set))                        ;; union
;(define (btree-remove))                     ;; difference
;(define (btree-update))                     ;; difference


;; TODO: testing.
(define (cmp m n) (if (< m n) -1 (if (= m n) 0 1)))
;(define p (btree-parameters 4 cmp))
(define p (btree-parameters 32 cmp))
;(define p (btree-parameters 256 cmp))
(alist->btree p '((1 . one) (5 . five) (3 . three) (11 . eleven) (-2 . -two)))

;(define test-keys (range 300))
(define test-keys (shuffle (range 40000)))
(define test-tree
  (time (alist->btree
          p (map (lambda (i)
                   (cons i (string-append "x" (number->string i))))
                 test-keys))))
;(pretty-print `(keys: ,test-keys))
;(pretty-print test-tree)
(pretty-print `(height: ,(btree-height test-tree)))
