#lang racket

(define (map f xs)
  (if (null? xs)
    '()
    (let ((a (f (car xs)))
          (d (map f (cdr xs))))
      (cons a d))))

(define (map/k k f xs)
  (if (null? xs)
    (k '())
    (f (lambda (a)
         (map/k (lambda (d) (k (cons a d)))
                f (cdr xs)))
       (car xs))))

(define (+1 x) (+ x 1))
(define (*2 x) (* x 2))
(define (*3 x) (* x 3))


;;;;;;;;;;;;;;;;;;
;; direct style ;;
;;;;;;;;;;;;;;;;;;
(define (H Ws)
  (let ((Xs (map +1 Ws)))
    (cons (map *2 Xs) (map *3 Xs))))

(define (H Ws)
  (let ((Xs (map +1 Ws)))
    (let ((Ys (map *2 Xs)))
      (let ((Zs (map *3 Xs)))
        (cons Ys Zs)))))

(let ((Xs (map +1 Ws)))
  (let ((Ys (map *2 Xs)))
    (let ((Zs (map *3 Xs)))
      (cons Ys Zs))))

(let ((Xs (if (null? Ws)
            '()
            (let ((A (+1 (car Ws)))
                  (D (map +1 (cdr Ws))))
              (cons A D)))))
  (let ((Ys (map *2 Xs)))
    (let ((Zs (map *3 Xs)))
      (cons Ys Zs))))

(if (null? Ws)
  (let ((Xs '()))
    (let ((Ys (map *2 Xs)))
      (let ((Zs (map *3 Xs)))
        (cons Ys Zs))))
  (let ((A (+1 (car Ws)))
        (D (map +1 (cdr Ws))))
    (let ((Xs (cons A D)))
      (let ((Ys (map *2 Xs)))
        (let ((Zs (map *3 Xs)))
          (cons Ys Zs))))))

(if (null? Ws)
  (cons '() '())
  (let ((A (+1 (car Ws)))
        (D (map +1 (cdr Ws))))
    (let ((Ys (map *2 (cons A D))))
      (let ((Zs (map *3 (cons A D))))
        (cons Ys Zs)))))

(if (null? Ws)
  (cons '() '())
  (let ((A (+1 (car Ws)))
        (D (map +1 (cdr Ws))))
    (let ((Ys (let ((A1 (*2 A))
                    (D1 (map *2 D)))
                (cons A1 D1))))
      (let ((Zs (let ((A2 (*3 A))
                      (D2 (map *3 D)))
                  (cons A2 D2))))
        (cons Ys Zs)))))

(if (null? Ws)
  (cons '() '())
  (let ((A (+1 (car Ws))))
    (let ((D (map +1 (cdr Ws))))
      (let ((Ys (let ((A1 (*2 A))  ;; *
                      (D1 (map *2 D)))
                  (cons A1 D1))))
        (let ((Zs (let ((A2 (*3 A))  ;; *
                        (D2 (map *3 D)))
                    (cons A2 D2))))
          (cons Ys Zs))))))

;; float pure bindings
(if (null? Ws)
  (cons '() '())
  (let ((A (+1 (car Ws))))
    (let ((A1 (*2 A)) (A2 (*3 A)))  ;; *
      (let ((D (map +1 (cdr Ws))))
        (let ((Ys (let ((D1 (map *2 D)))
                    (cons A1 D1))))
          (let ((Zs (let ((D2 (map *3 D)))
                      (cons A2 D2))))
            (cons Ys Zs)))))))

(if (null? Ws)
  (cons '() '())
  (let ((A (+1 (car Ws))))
    (let ((A1 (*2 A)) (A2 (*3 A)))
      (let ((D (map +1 (cdr Ws))))
        (let ((D1 (map *2 D)))
          (let ((D2 (map *3 D)))
            (cons (cons A1 D1) (cons A2 D2))))))))

;; Can we standardize this factoring?  Related to multi-value return.
(if (null? Ws)
  (cons '() '())
  (let ((A (+1 (car Ws))))
    (let ((A1 (*2 A)) (A2 (*3 A)))
      (let ((Rd (let ((D (map +1 (cdr Ws))))
                  (let ((D1 (map *2 D)))
                    (let ((D2 (map *3 D)))
                      (cons D1 D2))))))
        (cons (cons A1 (car Rd)) (cons A2 (cdr Rd)))))))

(if (null? Ws)
  (cons '() '())
  (let ((A (+1 (car Ws))))
    (let ((A1 (*2 A)) (A2 (*3 A)))
      (let ((Rd (H (cdr Ws))))
        (cons (cons A1 (car Rd)) (cons A2 (cdr Rd)))))))

(define (H Ws)
  (if (null? Ws)
    (cons '() '())
    (let ((A (+1 (car Ws))))
      (let ((A1 (*2 A)) (A2 (*3 A)))
        (let ((Rd (H (cdr Ws))))
          (cons (cons A1 (car Rd)) (cons A2 (cdr Rd))))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; cps (assume direct style for primitives +1 *2 *3 for simplicity ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (G/k K Ws)
  (map/k (lambda (Xs)
           (map/k (lambda (Ys)
                    (map/k (lambda (Zs) (K (cons Ys Zs)))
                           *3 Xs))
                  *2 Xs))
         +1 Ws))

;; worker/wrapper normalize for multi-value return
(define (G/k K Ws)
  (define (H/k J Ws)
    (map/k (lambda (Xs)
             (map/k (lambda (Ys)
                      (map/k (lambda (Zs) (J Ys Zs))
                             *3 Xs))
                    *2 Xs))
           +1 Ws))
  (H/k (lambda (Ys Zs) (K (cons Ys Zs))) Ws))

(map/k (lambda (Xs)
         (map/k (lambda (Ys)
                  (map/k (lambda (Zs) (J Ys Zs))
                         *3 Xs))
                *2 Xs))
       +1 Ws)

(if (null? Ws)
  ((lambda (Xs)
     (map/k (lambda (Ys)
              (map/k (lambda (Zs) (J Ys Zs))
                     *3 Xs))
            *2 Xs))
   '())
  (primcall +1 (lambda (A)
                 (map/k (lambda (D)
                          ((lambda (Xs)
                             (map/k (lambda (Ys)
                                      (map/k (lambda (Zs) (J Ys Zs))
                                             *3 Xs))
                                    *2 Xs))
                           (cons A D)))
                        +1 (cdr Ws)))
            (car Ws)))

(if (null? Ws)
  (map/k (lambda (Ys)
           (map/k (lambda (Zs) (J Ys Zs))
                  *3 '()))
         *2 '())
  (let ((A (+1 (car Ws))))
    (map/k (lambda (D)
             ((lambda (Xs)
                (map/k (lambda (Ys)
                         (map/k (lambda (Zs) (J Ys Zs))
                                *3 Xs))
                       *2 Xs))
              (cons A D)))
           +1 (cdr Ws))))

(if (null? Ws)
  (J '() '())
  (let ((A (+1 (car Ws))))
    (map/k (lambda (D)
             (let ((Xs (cons A D)))
               (map/k (lambda (Ys)
                        (map/k (lambda (Zs) (J Ys Zs))
                               *3 Xs))
                      *2 Xs)))
           +1 (cdr Ws))))

(if (null? Ws)
  (J '() '())
  (let ((A (+1 (car Ws))))
    (map/k (lambda (D)
             (let ((Xs (cons A D)))
               (primcall *2 (lambda (A1)
                              (map/k (lambda (D1)
                                       ((lambda (Ys)
                                          (map/k (lambda (Zs) (J Ys Zs))
                                                 *3 Xs))
                                        (cons A1 D1)))
                                     *2 D))
                         A)))
           +1 (cdr Ws))))

(if (null? Ws)
  (J '() '())
  (let ((A (+1 (car Ws))))
    (map/k (lambda (D)
             (let ((Xs (cons A D)))
               (let ((A1 (*2 A)))
                 (map/k (lambda (D1)
                          (let ((Ys (cons A1 D1)))
                            (map/k (lambda (Zs) (J Ys Zs))
                                   *3 Xs)))
                        *2 D))))
           +1 (cdr Ws))))

(if (null? Ws)
  (J '() '())
  (let ((A (+1 (car Ws))))
    (map/k (lambda (D)
             (let ((A1 (*2 A)))
               (map/k (lambda (D1)
                        (let ((Ys (cons A1 D1)))
                          (primcall *3 (lambda (A2)
                                         (map/k (lambda (D2)
                                                  ((lambda (Zs) (J Ys Zs))
                                                   (cons A2 D2)))
                                                *3 D))
                                    A)))
                      *2 D)))
           +1 (cdr Ws))))

(if (null? Ws)
  (J '() '())
  (let ((A (+1 (car Ws))))
    (map/k (lambda (D)
             (let ((A1 (*2 A)))  ;; *
               (map/k (lambda (D1)
                        (let ((Ys (cons A1 D1)))  ;; *
                          (let ((A2 (*3 A)))  ;; *
                            (map/k (lambda (D2)
                                     (let ((Zs (cons A2 D2)))
                                       (J Ys Zs)))
                                   *3 D))))
                      *2 D)))
           +1 (cdr Ws))))

;; float pure let bindings
(if (null? Ws)
  (J '() '())
  (let ((A (+1 (car Ws))))
    (let ((A1 (*2 A)) (A2 (*3 A)))  ;; *
      (map/k (lambda (D)
               (map/k (lambda (D1)
                        (map/k (lambda (D2)
                                 (let ((Ys (cons A1 D1)) (Zs (cons A2 D2)))  ;; *
                                   (J Ys Zs)))
                               *3 D))
                      *2 D))
             +1 (cdr Ws)))))

;; eta expand around term containing J to eliminate D1 and D2 dependency
(if (null? Ws)
  (J '() '())
  (let ((A (+1 (car Ws))))
    (let ((A1 (*2 A)) (A2 (*3 A)))
      (map/k (lambda (D)
               (map/k (lambda (D1)
                        (map/k (lambda (D2)
                                 ((lambda (D1 D2)
                                    (let ((Ys (cons A1 D1)) (Zs (cons A2 D2)))
                                      (J Ys Zs)))
                                  D1 D2))
                               *3 D))
                      *2 D))
             +1 (cdr Ws)))))

(if (null? Ws)
  (J '() '())
  (let ((A (+1 (car Ws))))
    (let ((A1 (*2 A)) (A2 (*3 A)))
      (H/k (lambda (D1 D2)
             (let ((Ys (cons A1 D1)) (Zs (cons A2 D2)))
               (J Ys Zs)))
           (cdr Ws)))))

(define (G/k K Ws)
  (define (H/k J Ws)
    (if (null? Ws)
      (J '() '())
      (let ((A (+1 (car Ws))))
        (let ((A1 (*2 A)) (A2 (*3 A)))
          (H/k (lambda (D1 D2)
                 (let ((Ys (cons A1 D1)) (Zs (cons A2 D2)))
                   (J Ys Zs)))
               (cdr Ws))))))
  (H/k (lambda (Ys Zs) (K (cons Ys Zs))) Ws))

(define (G/k K Ws)
  (define (H/k J Ws)
    (if (null? Ws)
      (J '() '())
      (let ((A (+1 (car Ws))))
        (let ((A1 (*2 A)) (A2 (*3 A)))
          (H/k (lambda (D1 D2) (J (cons A1 D1) (cons A2 D2)))
               (cdr Ws))))))
  (H/k (lambda (Ys Zs) (K (cons Ys Zs))) Ws))
