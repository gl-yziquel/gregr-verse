 eager and lazy CBV operational semantics
   CBV describes observable semantics while lazy/eager describes operational strategy
 eager CBV
   constructors with args need to save one-hole contexts
   all terms in focus are evaluated to completion with result values being catalogued
 lazy CBV
   constructors with args do not save any one-hole contexts
     they can punt on evaluating their args
     punted terms are paired with current environment and catalogued as eval obligations
   rewinding to evaluate an obligation
     pop catalog entries until desired key is found
     save popped entries (in reverse) with old context
     begin evaluating a new state with the remaining catalog
       (state clg-oblig-term (return-context (old-cont old-env reversed-entries)) clg-oblig-env)
     when returning to former context, re-push its entries onto the new catalog
   the catalog as described is actually a special case of a more general 'effect log'
     entry types can be added for memory allocation and writes
 given a catalog partitioning at any event boundary: members of older part do not depend on members of newer
   minimize duplication when splitting worlds around a hypothetical equality
     assumption boundary must be made before any key that would depend on it
       given key D being guessed
         assumption entry must be made before first E depending on D's value
         there may be entries between D and its assumption entry
           this would be because they depend on D's effects, but don't depend on D's value
       if made earlier than existing assumption, must split the splits
         this will happen with out-of-order case analysis on opaque values:
           first, case-analysis occurs on some D that happens to depend on C
           later, in one branch of (case D), retroactive case-analysis occurs on C
           the case-analysis on C must be pulled above that of D
             C's assumption entry must be made earlier than D's entry
             new split muts be made earlier than existing split, duplicating that split
             some waste produced (hopefully only temporarily) for the branch of D not analyzing C
       older keys definitely don't depend on assumption and make up the old region
       newer keys that happen to also not depend on assumption may be moved across it into the old region
         moving across also requires no effect dependencies
       old region ends up shared by both hypothetical worlds
   cleaning up after a transformation attempt on a subterm
     when producing result, only need to garbage collect entries newer than the subterm
   there should be a single key allocator so that every value, even across partitions/worlds, has a unique key
     when partitioning based on hypothetical equality, copy all keys dependent on assumed value
       when re-combining worlds, new world only contributes keys newer than split
 assumptions in effect log mark when the world split
   new world not responsible for old effects, though may evaluate them under assumptions to see what they would provide
   when re-combining with old world, only effects after assumption are contributed
   after re-combining, assumptions are used to unify target keys and generate code to define new keys
 diagram:
   example of optimal assumption placement
   case D, where e's depend on D, c's do not depend on D at all, x's depend only on D's effect
 newer ---------------------------------- older
 ... e e e e (assume D = _) x x x D c c c c ...

 future small-step ideas
(data assumption
  (assume-eq (key0 key1))
  (assume-neq (key0 key1))
  (assume-value (key new-keys value)))
(data clg-entry
  (clg-data (kvs)))   plural, allowing SCCs (let-rec) to satisfy partition property
  (clg-obligation (key term env notes))
  (clg-assumption (assumed)))
  (clg-memory-effect ())
  (clg-stream-effect ())
  (clg-reset (marker))
  etc.
(data cont
  (ohc (cont oh))
  (halt ())
  (return-caller (cont env)))
  (return-context (cont env clg-replay)))

